This workshop has helped me understand how smart pointers and raw pointers from the memory library are used and their differences. The syntax for smart pointers is slightly lengthier compared to its raw counterpart, for example in the mergeSmart function the pointer is declared by std::unique_ptr<Product> newProduct(new Product(desc[indexD].desc, price[indexP].price));, as opposed to Product *newProduct = new Product(desc[indexD].desc, price[indexP].price); in mergeRaw. A great convenience that a smart pointer have is that they are deleted automically when it is no longer needed, this can greatly reduce the likelihood of memory leaks. In the case of the workshop, mergeRaw uses raw pointers and still requires the implementation of a delete to ensure that no memory leaks occur, while mergeSmart uses unique_ptr and it get destructed automatically when needed. Aside from unique_ptr in the workshop, shared_ptr is also considered a smart pointer. Shared pointers are useful for managing objects with many-to-one relationships. share_ptr accomplishes this task by keeping track of the pointers pointed towards the same objects.